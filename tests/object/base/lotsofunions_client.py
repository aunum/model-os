# This file was generated by ModelOS
import json
import os
import typing
from pathlib import Path
from typing import Type
from urllib import request

from lib_programname import get_path_executed_script

import modelos.object.kind
from modelos import Client
from modelos.object.encoding import deep_isinstance, json_is_type_match
from modelos.object.opts import Opts, OptsBuilder

from .base_test import Ham

if get_path_executed_script() == Path(os.path.dirname(__file__)).joinpath(Path("base_test.py")):
    from __main__ import Ham  # type: ignore # noqa


class LotsOfUnionsClient(Client):
    """A resource client for LotsOfUnions"""

    uri: str = "aunum/mdl-test:lotsofunions-3967177-d4c3cd7"

    def __init__(
        self,
        a: typing.Union[str, int],
        b: typing.Union[typing.Dict[str, typing.Any], typing.List[str]],
        c: typing.Optional[bool] = None,
        **kwargs,
    ) -> None:
        """A LotsOfUnions resource

        Args:
            a (Union[str, int]): An a
            b (Union[Dict[str, Any], List[str]]): A b
            c (Optional[bool], optional): A c. Defaults to None.
        """
        ClientOpts = OptsBuilder[Opts].build(self.__class__)
        opts = ClientOpts(a=a, b=b, c=c)  # type: ignore
        super().__init__(opts=opts, **kwargs)

    def echo(self, txt: typing.Optional[str] = None) -> str:
        """Echo a string back

        Args:
            txt (str): String to echo

        Returns:
            str: String echoed with a hello
        """
        # code for union: typing.Optional[str]
        if deep_isinstance(txt, None):
            pass
        elif deep_isinstance(txt, str):
            pass
        else:
            raise ValueError("Do not know how to serialize " + "parameter 'txt' " + f"of type '{type(txt)}'")
        # end union: typing.Optional[str]

        _params = json.dumps({"txt": txt}).encode("utf8")
        _headers = {"content-type": "application/json", "client-uuid": str(self.uid)}
        _req = request.Request(
            f"{self.server_addr}/echo",
            data=_params,
            headers=_headers,
        )
        _resp = request.urlopen(_req)
        _data = _resp.read().decode("utf-8")
        _jdict = json.loads(_data)

        if _jdict is None:
            raise ValueError("recieved invalid response from server, check server logs")

        if "value" in _jdict:
            _jdict = _jdict["value"]

        _ret: str
        _ret = _jdict

        return _ret

    def health(self) -> typing.Dict[str, str]:
        """Health of the resource

        Returns:
            Dict[str, Any]: Resource health
        """

        _params = json.dumps({}).encode("utf8")
        _headers = {"content-type": "application/json", "client-uuid": str(self.uid)}
        _req = request.Request(
            f"{self.server_addr}/health",
            data=_params,
            headers=_headers,
        )
        _resp = request.urlopen(_req)
        _data = _resp.read().decode("utf-8")
        _jdict = json.loads(_data)

        if _jdict is None:
            raise ValueError("recieved invalid response from server, check server logs")

        if "value" in _jdict:
            _jdict = _jdict["value"]

        _ret: typing.Dict[str, str]
        # code for arg: typing.Dict[str, str]
        if not json_is_type_match(typing.Dict[str, str], _jdict):
            raise ValueError("JSON returned does not match type: typing.Dict[str, str]")
        _ret = _jdict
        # end dict: typing.Dict[str, str]

        return _ret

    def info(self) -> modelos.object.kind.ObjectInfo:
        """Info about the resource

        Returns:
            Dict[str, Any]: Resource info
        """

        _params = json.dumps({}).encode("utf8")
        _headers = {"content-type": "application/json", "client-uuid": str(self.uid)}
        _req = request.Request(
            f"{self.server_addr}/info",
            data=_params,
            headers=_headers,
        )
        _resp = request.urlopen(_req)
        _data = _resp.read().decode("utf-8")
        _jdict = json.loads(_data)

        if _jdict is None:
            raise ValueError("recieved invalid response from server, check server logs")

        if "value" in _jdict:
            _jdict = _jdict["value"]

        _ret: modelos.object.kind.ObjectInfo
        # code for object: <class 'modelos.object.kind.ObjectInfo'>
        if not json_is_type_match(modelos.object.kind.ObjectInfo, _jdict):
            raise ValueError("JSON returned does not match type: modelos.object.kind.ObjectInfo")
        _ret_obj = object.__new__(modelos.object.kind.ObjectInfo)  # type: ignore
        _name = _jdict["name"]
        setattr(_ret_obj, "name", _name)

        _version = _jdict["version"]
        setattr(_ret_obj, "version", _version)

        _env_sha = _jdict["env_sha"]
        setattr(_ret_obj, "env_sha", _env_sha)

        _uri = _jdict["uri"]
        setattr(_ret_obj, "uri", _uri)

        _server_entrypoint = _jdict["server_entrypoint"]
        setattr(_ret_obj, "server_entrypoint", _server_entrypoint)

        _locked = _jdict["locked"]
        setattr(_ret_obj, "locked", _locked)

        _ext = _jdict["ext"]
        # code for union: typing.Optional[typing.Dict[str, str]]
        if json_is_type_match(typing.Dict[str, str], _ext):
            # code for arg: typing.Dict[str, str]
            _ret = _ext
            # end dict: typing.Dict[str, str]

        elif json_is_type_match(None, _ext):
            _ret = _ext
        else:
            raise ValueError(f"Unable to deserialize return value: {type(_ext)}")
        # end union: typing.Optional[typing.Dict[str, str]]

        setattr(_ret_obj, "ext", _ext)

        _ret = _ret_obj
        # end object: <class 'modelos.object.kind.ObjectInfo'>

        return _ret

    def lock(self, key: typing.Optional[str] = None, timeout: typing.Optional[int] = None) -> None:
        """Lock the process to only operate with the caller

        Args:
            key (Optional[str], optional): An optional key to secure the lock
            timeout (Optional[int], optional): Whether to unlock after a set amount of time. Defaults to None.
        """
        # code for union: typing.Optional[str]
        if deep_isinstance(key, None):
            pass
        elif deep_isinstance(key, str):
            pass
        else:
            raise ValueError("Do not know how to serialize " + "parameter 'key' " + f"of type '{type(key)}'")
        # end union: typing.Optional[str]

        # code for union: typing.Optional[int]
        if deep_isinstance(timeout, None):
            pass
        elif deep_isinstance(timeout, int):
            pass
        else:
            raise ValueError("Do not know how to serialize " + "parameter 'timeout' " + f"of type '{type(timeout)}'")
        # end union: typing.Optional[int]

        _params = json.dumps({"key": key, "timeout": timeout}).encode("utf8")
        _headers = {"content-type": "application/json", "client-uuid": str(self.uid)}
        _req = request.Request(
            f"{self.server_addr}/lock",
            data=_params,
            headers=_headers,
        )
        _resp = request.urlopen(_req)
        _data = _resp.read().decode("utf-8")
        _jdict = json.loads(_data)

        if _jdict is None:
            raise ValueError("recieved invalid response from server, check server logs")

        if "value" in _jdict:
            _jdict = _jdict["value"]

        _ret: None
        _ret = _jdict

        return _ret

    def optional_lists(
        self,
        y: typing.Union[typing.List[Ham], typing.Dict[str, Ham]],
        as_dict: bool = True,
    ) -> typing.Union[typing.List[Ham], typing.Dict[str, Ham]]:
        """Recieves lists and dictionaries of Ham

        Args:
            y (Union[List[Ham], Dict[str, Ham]]): A list or dictionary of Ham
            as_dict (bool, optional): Return as a dicdtionary. Defaults to True.

        Returns:
            Union[List[Ham], Dict[str, Ham]]: A list or a dictionary of Ham
        """
        # code for union: typing.Union[typing.List[__main__.Ham], typing.Dict[str, __main__.Ham]]
        if deep_isinstance(y, typing.List[Ham]):
            # code for list arg: typing.List[__main__.Ham]
            _y_list = []
            for _a_val in y:  # type: ignore
                # code for object: <class '__main__.Ham'>
                _a_val = _a_val.__dict__  # type: ignore
                # end object: <class '__main__.Ham'>

                _y_list.append(_a_val)
            y = _y_list  # type: ignore
            # end list: typing.List[__main__.Ham]

        elif deep_isinstance(y, typing.Dict[str, Ham]):
            # code for dict arg: typing.Dict[str, __main__.Ham]
            _y_dict = {}
            for _b_key, _c_val in y.items():  # type: ignore
                # code for object: <class '__main__.Ham'>
                _c_val = _c_val.__dict__  # type: ignore
                # end object: <class '__main__.Ham'>

                _y_dict[_b_key] = _c_val  # type: ignore
            y = _y_dict  # type: ignore
            # end dict: typing.Dict[str, __main__.Ham]

        else:
            raise ValueError("Do not know how to serialize " + "parameter 'y' " + f"of type '{type(y)}'")
        # end union: typing.Union[typing.List[__main__.Ham], typing.Dict[str, __main__.Ham]]

        _params = json.dumps({"y": y, "as_dict": as_dict}).encode("utf8")
        _headers = {"content-type": "application/json", "client-uuid": str(self.uid)}
        _req = request.Request(
            f"{self.server_addr}/optional_lists",
            data=_params,
            headers=_headers,
        )
        _resp = request.urlopen(_req)
        _data = _resp.read().decode("utf-8")
        _jdict = json.loads(_data)

        if _jdict is None:
            raise ValueError("recieved invalid response from server, check server logs")

        if "value" in _jdict:
            _jdict = _jdict["value"]

        _ret: typing.Union[typing.List[Ham], typing.Dict[str, Ham]]
        # code for union: typing.Union[typing.List[__main__.Ham], typing.Dict[str, __main__.Ham]]
        if json_is_type_match(typing.List[Ham], _jdict):
            # code for arg: typing.List[__main__.Ham]
            _e_list: typing.List = []
            for _d_val in _jdict:
                # code for object: <class '__main__.Ham'>
                if not json_is_type_match(Ham, _d_val):
                    raise ValueError("JSON returned does not match type: Ham")
                _e_obj = object.__new__(Ham)  # type: ignore
                _a = _d_val["a"]
                setattr(_e_obj, "a", _a)

                _b = _d_val["b"]
                setattr(_e_obj, "b", _b)

                _e = _e_obj
                # end object: <class '__main__.Ham'>

                _e_list.append(_e)
            _ret = _e_list
            # end list: typing.List[__main__.Ham]

        elif json_is_type_match(typing.Dict[str, Ham], _jdict):
            # code for arg: typing.Dict[str, __main__.Ham]
            _f_dict: typing.Dict[str, Ham] = {}
            for _g_key, _h_val in _jdict.items():
                # code for object: <class '__main__.Ham'>
                if not json_is_type_match(Ham, _h_val):
                    raise ValueError("JSON returned does not match type: Ham")
                _f_obj = object.__new__(Ham)  # type: ignore
                _a = _h_val["a"]
                setattr(_f_obj, "a", _a)

                _b = _h_val["b"]
                setattr(_f_obj, "b", _b)

                _f = _f_obj
                # end object: <class '__main__.Ham'>

                _f_dict[_g_key] = _f  # type: ignore
            _ret = _f_dict
            # end dict: typing.Dict[str, __main__.Ham]

        else:
            raise ValueError(f"Unable to deserialize return value: {type(_jdict)}")
        # end union: typing.Union[typing.List[__main__.Ham], typing.Dict[str, __main__.Ham]]

        return _ret

    def optional_obj(
        self,
        h: typing.Union[Ham, typing.Dict[str, typing.Any]],
        return_dict: typing.Optional[bool] = None,
    ) -> typing.Union[Ham, typing.Dict[str, typing.Any]]:
        """Receives either a Ham or a dictionary and optionally returns a ham

        Args:
            h (Union[Ham, Dict[str, Any]]): A Ham or a dictionary of Ham

        Returns:
            Union[Ham, Dict[str, Any]]: A Ham or nothing
        """
        # code for union: typing.Union[__main__.Ham, typing.Dict[str, typing.Any]]
        if deep_isinstance(h, Ham):
            # code for object: <class '__main__.Ham'>
            h = h.__dict__  # type: ignore
            # end object: <class '__main__.Ham'>

        elif deep_isinstance(h, typing.Dict[str, typing.Any]):
            # code for dict arg: typing.Dict[str, typing.Any]
            _h_dict = {}
            for _a_key, _b_val in h.items():  # type: ignore
                _h_dict[_a_key] = _b_val  # type: ignore
            h = _h_dict  # type: ignore
            # end dict: typing.Dict[str, typing.Any]

        else:
            raise ValueError("Do not know how to serialize " + "parameter 'h' " + f"of type '{type(h)}'")
        # end union: typing.Union[__main__.Ham, typing.Dict[str, typing.Any]]

        # code for union: typing.Optional[bool]
        if deep_isinstance(return_dict, None):
            pass
        elif deep_isinstance(return_dict, bool):
            pass
        else:
            raise ValueError(
                "Do not know how to serialize " + "parameter 'return_dict' " + f"of type '{type(return_dict)}'"
            )
        # end union: typing.Optional[bool]

        _params = json.dumps({"h": h, "return_dict": return_dict}).encode("utf8")
        _headers = {"content-type": "application/json", "client-uuid": str(self.uid)}
        _req = request.Request(
            f"{self.server_addr}/optional_obj",
            data=_params,
            headers=_headers,
        )
        _resp = request.urlopen(_req)
        _data = _resp.read().decode("utf-8")
        _jdict = json.loads(_data)

        if _jdict is None:
            raise ValueError("recieved invalid response from server, check server logs")

        if "value" in _jdict:
            _jdict = _jdict["value"]

        _ret: typing.Union[Ham, typing.Dict[str, typing.Any]]
        # code for union: typing.Union[__main__.Ham, typing.Dict[str, typing.Any]]
        if json_is_type_match(Ham, _jdict):
            # code for object: <class '__main__.Ham'>
            if not json_is_type_match(Ham, _jdict):
                raise ValueError("JSON returned does not match type: Ham")
            _ret_obj = object.__new__(Ham)  # type: ignore
            _a = _jdict["a"]
            setattr(_ret_obj, "a", _a)

            _b = _jdict["b"]
            setattr(_ret_obj, "b", _b)

            _ret = _ret_obj
            # end object: <class '__main__.Ham'>

        elif json_is_type_match(typing.Dict[str, typing.Any], _jdict):
            # code for arg: typing.Dict[str, typing.Any]
            _c_dict: typing.Dict[str, typing.Any] = {}
            for _d_key, _e_val in _jdict.items():
                _c = _e_val
                _c_dict[_d_key] = _c  # type: ignore
            _ret = _c_dict
            # end dict: typing.Dict[str, typing.Any]

        else:
            raise ValueError(f"Unable to deserialize return value: {type(_jdict)}")
        # end union: typing.Union[__main__.Ham, typing.Dict[str, typing.Any]]

        return _ret

    def optional_tuples(
        self, x: typing.Union[typing.Tuple[str, Ham], typing.Dict[str, Ham]]
    ) -> typing.Union[typing.Tuple[str, Ham], typing.Dict[str, Ham]]:
        """Handle optional tuples

        Args:
            x (Union[Tuple[str, Ham], Dict[str, Ham]]): A union of Tuple

        Returns:
            Union[Tuple[str, Ham], Dict[str, Ham]]: A union of Tuple
        """
        # code for union: typing.Union[typing.Tuple[str, __main__.Ham], typing.Dict[str, __main__.Ham]]
        if deep_isinstance(x, typing.Tuple[str, Ham]):
            # code for tuple: typing.Tuple[str, __main__.Ham]
            x_list: typing.List[typing.Any] = []
            # code for tuple arg: <class 'str'>
            x_0 = x[0]  # type: ignore
            x_list.append(x_0)
            # end tuple arg: <class 'str'>

            # code for tuple arg: <class '__main__.Ham'>
            x_1 = x[1]  # type: ignore
            # code for object: <class '__main__.Ham'>
            x_1 = x_1.__dict__  # type: ignore
            # end object: <class '__main__.Ham'>

            x_list.append(x_1)
            # end tuple arg: <class '__main__.Ham'>

            x = x_list  # type: ignore
            # end tuple: typing.Tuple[str, __main__.Ham]

        elif deep_isinstance(x, typing.Dict[str, Ham]):
            # code for dict arg: typing.Dict[str, __main__.Ham]
            _x_dict = {}
            for _a_key, _b_val in x.items():  # type: ignore
                # code for object: <class '__main__.Ham'>
                _b_val = _b_val.__dict__  # type: ignore
                # end object: <class '__main__.Ham'>

                _x_dict[_a_key] = _b_val  # type: ignore
            x = _x_dict  # type: ignore
            # end dict: typing.Dict[str, __main__.Ham]

        else:
            raise ValueError("Do not know how to serialize " + "parameter 'x' " + f"of type '{type(x)}'")
        # end union: typing.Union[typing.Tuple[str, __main__.Ham], typing.Dict[str, __main__.Ham]]

        _params = json.dumps({"x": x}).encode("utf8")
        _headers = {"content-type": "application/json", "client-uuid": str(self.uid)}
        _req = request.Request(
            f"{self.server_addr}/optional_tuples",
            data=_params,
            headers=_headers,
        )
        _resp = request.urlopen(_req)
        _data = _resp.read().decode("utf-8")
        _jdict = json.loads(_data)

        if _jdict is None:
            raise ValueError("recieved invalid response from server, check server logs")

        if "value" in _jdict:
            _jdict = _jdict["value"]

        _ret: typing.Union[typing.Tuple[str, Ham], typing.Dict[str, Ham]]
        # code for union: typing.Union[typing.Tuple[str, __main__.Ham], typing.Dict[str, __main__.Ham]]
        if json_is_type_match(typing.Tuple[str, Ham], _jdict):
            # code for tuple: typing.Tuple[str, __main__.Ham]
            _ret_tuple: typing.Tuple[str, Ham] = ()  # type: ignore

            # code for tuple arg: <class 'str'>
            _v_0 = _jdict[0]
            _c = _v_0
            _ret_tuple = _ret_tuple + (_c,)  # type: ignore
            # end tuple arg: <class 'str'>

            # code for tuple arg: <class '__main__.Ham'>
            _v_1 = _jdict[1]
            # code for object: <class '__main__.Ham'>
            if not json_is_type_match(Ham, _v_1):
                raise ValueError("JSON returned does not match type: Ham")
            _d_obj = object.__new__(Ham)  # type: ignore
            _a = _v_1["a"]
            setattr(_d_obj, "a", _a)

            _b = _v_1["b"]
            setattr(_d_obj, "b", _b)

            _d = _d_obj
            # end object: <class '__main__.Ham'>

            _ret_tuple = _ret_tuple + (_d,)  # type: ignore
            # end tuple arg: <class '__main__.Ham'>

            _ret = _ret_tuple  # type: ignore
            # end tuple: typing.Tuple[str, __main__.Ham]

        elif json_is_type_match(typing.Dict[str, Ham], _jdict):
            # code for arg: typing.Dict[str, __main__.Ham]
            _e_dict: typing.Dict[str, Ham] = {}
            for _f_key, _g_val in _jdict.items():
                # code for object: <class '__main__.Ham'>
                if not json_is_type_match(Ham, _g_val):
                    raise ValueError("JSON returned does not match type: Ham")
                _e_obj = object.__new__(Ham)  # type: ignore
                _a = _g_val["a"]
                setattr(_e_obj, "a", _a)

                _b = _g_val["b"]
                setattr(_e_obj, "b", _b)

                _e = _e_obj
                # end object: <class '__main__.Ham'>

                _e_dict[_f_key] = _e  # type: ignore
            _ret = _e_dict
            # end dict: typing.Dict[str, __main__.Ham]

        else:
            raise ValueError(f"Unable to deserialize return value: {type(_jdict)}")
        # end union: typing.Union[typing.Tuple[str, __main__.Ham], typing.Dict[str, __main__.Ham]]

        return _ret

    def returns_optional(self, a: typing.Union[str, int]) -> typing.Optional[str]:
        """Optionally returns the given string or returns None if int

        Args:
            a (Union[str, int]): A string or int

        Returns:
            Optional[str]: An optional string
        """
        # code for union: typing.Union[str, int]
        if deep_isinstance(a, str):
            pass
        elif deep_isinstance(a, int):
            pass
        else:
            raise ValueError("Do not know how to serialize " + "parameter 'a' " + f"of type '{type(a)}'")
        # end union: typing.Union[str, int]

        _params = json.dumps({"a": a}).encode("utf8")
        _headers = {"content-type": "application/json", "client-uuid": str(self.uid)}
        _req = request.Request(
            f"{self.server_addr}/returns_optional",
            data=_params,
            headers=_headers,
        )
        _resp = request.urlopen(_req)
        _data = _resp.read().decode("utf-8")
        _jdict = json.loads(_data)

        if _jdict is None:
            raise ValueError("recieved invalid response from server, check server logs")

        if "value" in _jdict:
            _jdict = _jdict["value"]

        _ret: typing.Optional[str]
        # code for union: typing.Optional[str]
        if json_is_type_match(str, _jdict):
            _ret = _jdict
        elif json_is_type_match(None, _jdict):
            _ret = _jdict
        else:
            raise ValueError(f"Unable to deserialize return value: {type(_jdict)}")
        # end union: typing.Optional[str]

        return _ret

    def save(self, out_dir: str = "./artifacts") -> None:
        """Save the object

        Args:
            out_dir (str, optional): Directory to output the artiacts. Defaults to "./artifacts".
        """

        _params = json.dumps({"out_dir": out_dir}).encode("utf8")
        _headers = {"content-type": "application/json", "client-uuid": str(self.uid)}
        _req = request.Request(
            f"{self.server_addr}/save",
            data=_params,
            headers=_headers,
        )
        _resp = request.urlopen(_req)
        _data = _resp.read().decode("utf-8")
        _jdict = json.loads(_data)

        if _jdict is None:
            raise ValueError("recieved invalid response from server, check server logs")

        if "value" in _jdict:
            _jdict = _jdict["value"]

        _ret: None
        _ret = _jdict

        return _ret

    def unlock(self, key: typing.Optional[str] = None, force: bool = False) -> None:
        """Unlock the kind

        Args:
            key (Optional[str], optional): Key to unlock, if needed. Defaults to None.
            force (bool, optional): Force unlock without a key. Defaults to False.
        """
        # code for union: typing.Optional[str]
        if deep_isinstance(key, None):
            pass
        elif deep_isinstance(key, str):
            pass
        else:
            raise ValueError("Do not know how to serialize " + "parameter 'key' " + f"of type '{type(key)}'")
        # end union: typing.Optional[str]

        _params = json.dumps({"key": key, "force": force}).encode("utf8")
        _headers = {"content-type": "application/json", "client-uuid": str(self.uid)}
        _req = request.Request(
            f"{self.server_addr}/unlock",
            data=_params,
            headers=_headers,
        )
        _resp = request.urlopen(_req)
        _data = _resp.read().decode("utf-8")
        _jdict = json.loads(_data)

        if _jdict is None:
            raise ValueError("recieved invalid response from server, check server logs")

        if "value" in _jdict:
            _jdict = _jdict["value"]

        _ret: None
        _ret = _jdict

        return _ret

    def labels(self) -> typing.Dict[str, str]:  # type: ignore
        """Labels for the resource

        Args:
            scm (Optional[SCM], optional): SCM to use. Defaults to None.

        Returns:
            Dict[str, Any]: Labels for the server
        """

        _params = json.dumps({}).encode("utf8")
        _headers = {"content-type": "application/json", "client-uuid": str(self.uid)}
        _req = request.Request(
            f"{self.server_addr}/labels",
            data=_params,
            headers=_headers,
        )
        _resp = request.urlopen(_req)
        _data = _resp.read().decode("utf-8")
        _jdict = json.loads(_data)

        if _jdict is None:
            raise ValueError("recieved invalid response from server, check server logs")

        if "value" in _jdict:
            _jdict = _jdict["value"]

        _ret: typing.Dict[str, str]
        # code for arg: typing.Dict[str, str]
        if not json_is_type_match(typing.Dict[str, str], _jdict):
            raise ValueError("JSON returned does not match type: typing.Dict[str, str]")
        _ret = _jdict
        # end dict: typing.Dict[str, str]

        return _ret

    def name(self) -> str:  # type: ignore
        """Name of the resource

        Returns:
            str: Name of the server
        """

        _params = json.dumps({}).encode("utf8")
        _headers = {"content-type": "application/json", "client-uuid": str(self.uid)}
        _req = request.Request(
            f"{self.server_addr}/name",
            data=_params,
            headers=_headers,
        )
        _resp = request.urlopen(_req)
        _data = _resp.read().decode("utf-8")
        _jdict = json.loads(_data)

        if _jdict is None:
            raise ValueError("recieved invalid response from server, check server logs")

        if "value" in _jdict:
            _jdict = _jdict["value"]

        _ret: str
        _ret = _jdict

        return _ret

    def short_name(self) -> str:  # type: ignore
        """Short name for the resource

        Returns:
            str: A short name
        """

        _params = json.dumps({}).encode("utf8")
        _headers = {"content-type": "application/json", "client-uuid": str(self.uid)}
        _req = request.Request(
            f"{self.server_addr}/short_name",
            data=_params,
            headers=_headers,
        )
        _resp = request.urlopen(_req)
        _data = _resp.read().decode("utf-8")
        _jdict = json.loads(_data)

        if _jdict is None:
            raise ValueError("recieved invalid response from server, check server logs")

        if "value" in _jdict:
            _jdict = _jdict["value"]

        _ret: str
        _ret = _jdict

        return _ret

    def _super_init(self, uri: str) -> None:
        super().__init__(uri)

    @classmethod
    def from_uri(cls: Type["LotsOfUnionsClient"], uri: str) -> "LotsOfUnionsClient":
        c = cls.__new__(cls)
        c._super_init(uri)
        return c
