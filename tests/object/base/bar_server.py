# This file was generated by ModelOS
import json
import logging
import os
import typing
from typing import List
from urllib import parse

import base_test
import uvicorn
from starlette.applications import Starlette
from starlette.responses import JSONResponse
from starlette.routing import BaseRoute, Route, WebSocketRoute

from modelos.object.encoding import deep_isinstance, json_is_type_match

log_level = os.getenv("LOG_LEVEL")
if log_level is None:
    logging.basicConfig(level=logging.INFO)
else:
    logging.basicConfig(level=log_level)


class BarServer(base_test.Bar):
    """A resource server for Bar"""

    async def _add_req(self, request):
        """Request for function:
        add(self, x: int, y: int) -> int
        """

        body = await request.body()
        print("len body: ", len(body))
        print("body: ", body)

        _jdict = {}
        if len(body) != 0:
            _jdict = json.loads(body)

        headers = request.headers
        logging.debug(f"headers: {headers}")
        self._check_lock(headers)

        print("calling function: ", _jdict)
        _ret = self.add(**_jdict)
        print("called function: ", _ret)
        _ret = {"value": _ret}

        print("returning: ", _ret)
        return JSONResponse(_ret)

    async def _bake_hams_req(self, request):
        """Request for function:
        bake_hams(self, ham_by_name: Dict[str, __main__.Ham]) -> Dict[str, __main__.Ham]  # noqa
        """

        body = await request.body()
        print("len body: ", len(body))
        print("body: ", body)

        _jdict = {}
        if len(body) != 0:
            _jdict = json.loads(body)

        headers = request.headers
        logging.debug(f"headers: {headers}")
        self._check_lock(headers)

        _ham_by_name = _jdict["ham_by_name"]
        # code for dict: typing.Dict[str, base_test.Ham]
        if not json_is_type_match(typing.Dict[str, base_test.Ham], _ham_by_name):
            raise ValueError(
                "JSON from 'ham_by_name' returned does not match type: typing.Dict[str, __main__.Ham]"
            )

        _ham_by_name_dict: typing.Dict[str, base_test.Ham] = {}
        for _a_key, _b_val in _ham_by_name.items():
            # code for obj: base_test.Ham
            _b_val_obj = object.__new__(base_test.Ham)
            _a_attr = _b_val["a"]
            setattr(_b_val_obj, "a", _a_attr)

            _b_attr = _b_val["b"]
            setattr(_b_val_obj, "b", _b_attr)

            _b_val = _b_val_obj  # type: ignore
            # end obj: base_test.Ham

            _ham_by_name_dict[_a_key] = _b_val  # type: ignore
        _ham_by_name = _ham_by_name_dict
        # end dict: typing.Dict[str, base_test.Ham]

        _jdict["ham_by_name"] = _ham_by_name

        print("calling function: ", _jdict)
        _ret = self.bake_hams(**_jdict)
        print("called function: ", _ret)
        # code for dict arg: typing.Dict[str, __main__.Ham]
        _ret_dict = {}
        for _c_key, _d_val in _ret.items():  # type: ignore
            # code for object: <class '__main__.Ham'>
            _d_val = _d_val.__dict__  # type: ignore
            # end object: <class '__main__.Ham'>

            _ret_dict[_c_key] = _d_val  # type: ignore
        _ret = _ret_dict
        # end dict: typing.Dict[str, __main__.Ham]

        print("returning: ", _ret)
        return JSONResponse(_ret)

    async def _cook_eggs_req(self, request):
        """Request for function:
        cook_eggs(self, egg_by_name: Dict[str, __main__.Eggs]) -> Dict[str, __main__.Eggs]  # noqa
        """

        body = await request.body()
        print("len body: ", len(body))
        print("body: ", body)

        _jdict = {}
        if len(body) != 0:
            _jdict = json.loads(body)

        headers = request.headers
        logging.debug(f"headers: {headers}")
        self._check_lock(headers)

        _egg_by_name = _jdict["egg_by_name"]
        # code for dict: typing.Dict[str, base_test.Eggs]
        if not json_is_type_match(typing.Dict[str, base_test.Eggs], _egg_by_name):
            raise ValueError(
                "JSON from 'egg_by_name' returned does not match type: typing.Dict[str, __main__.Eggs]"
            )

        _egg_by_name_dict: typing.Dict[str, base_test.Eggs] = {}
        for _a_key, _b_val in _egg_by_name.items():
            # code for obj: base_test.Eggs
            _b_val_obj = object.__new__(base_test.Eggs)
            _h_attr = _b_val["h"]

            # code for obj: base_test.Ham
            _h_attr_obj = object.__new__(base_test.Ham)
            _a_attr = _h_attr["a"]
            setattr(_h_attr_obj, "a", _a_attr)

            _b_attr = _h_attr["b"]
            setattr(_h_attr_obj, "b", _b_attr)

            _h_attr = _h_attr_obj  # type: ignore
            # end obj: base_test.Ham

            setattr(_b_val_obj, "h", _h_attr)

            _b_attr = _b_val["b"]
            # code for dict: typing.Dict[str, base_test.Ham]
            if not json_is_type_match(typing.Dict[str, base_test.Ham], _b_attr):
                raise ValueError(
                    "JSON from 'b_attr' returned does not match type: typing.Dict[str, __main__.Ham]"
                )

            _b_attr_dict: typing.Dict[str, base_test.Ham] = {}
            for _c_key, _d_val in _b_attr.items():
                # code for obj: base_test.Ham
                _d_val_obj = object.__new__(base_test.Ham)
                _a_attr = _d_val["a"]
                setattr(_d_val_obj, "a", _a_attr)

                _b_attr = _d_val["b"]
                setattr(_d_val_obj, "b", _b_attr)

                _d_val = _d_val_obj  # type: ignore
                # end obj: base_test.Ham

                _b_attr_dict[_c_key] = _d_val  # type: ignore
            _b_attr = _b_attr_dict
            # end dict: typing.Dict[str, base_test.Ham]

            setattr(_b_val_obj, "b", _b_attr)

            _b_val = _b_val_obj  # type: ignore
            # end obj: base_test.Eggs

            _egg_by_name_dict[_a_key] = _b_val  # type: ignore
        _egg_by_name = _egg_by_name_dict
        # end dict: typing.Dict[str, base_test.Eggs]

        _jdict["egg_by_name"] = _egg_by_name

        print("calling function: ", _jdict)
        _ret = self.cook_eggs(**_jdict)
        print("called function: ", _ret)
        # code for dict arg: typing.Dict[str, __main__.Eggs]
        _ret_dict = {}
        for _e_key, _f_val in _ret.items():  # type: ignore
            # code for object: <class '__main__.Eggs'>
            _f_val = _f_val.__dict__  # type: ignore
            _h: base_test.Ham = _f_val["h"]
            # code for object: <class '__main__.Ham'>
            _h = _h.__dict__  # type: ignore
            # end object: <class '__main__.Ham'>

            _f_val["h"] = _h
            _b: typing.Dict[str, base_test.Ham] = _f_val["b"]
            # code for dict arg: typing.Dict[str, __main__.Ham]
            _b_dict = {}
            for _g_key, _h_val in _b.items():  # type: ignore
                # code for object: <class '__main__.Ham'>
                _h_val = _h_val.__dict__  # type: ignore
                # end object: <class '__main__.Ham'>

                _b_dict[_g_key] = _h_val  # type: ignore
            _b = _b_dict
            # end dict: typing.Dict[str, __main__.Ham]

            _f_val["b"] = _b
            # end object: <class '__main__.Eggs'>

            _ret_dict[_e_key] = _f_val  # type: ignore
        _ret = _ret_dict
        # end dict: typing.Dict[str, __main__.Eggs]

        print("returning: ", _ret)
        return JSONResponse(_ret)

    async def _echo_req(self, request):
        """Request for function:
        echo(self, txt: str) -> str
        """

        body = await request.body()
        print("len body: ", len(body))
        print("body: ", body)

        _jdict = {}
        if len(body) != 0:
            _jdict = json.loads(body)

        headers = request.headers
        logging.debug(f"headers: {headers}")
        self._check_lock(headers)

        print("calling function: ", _jdict)
        _ret = self.echo(**_jdict)
        print("called function: ", _ret)
        _ret = {"value": _ret}

        print("returning: ", _ret)
        return JSONResponse(_ret)

    async def _echo_ham_req(self, request):
        """Request for function:
        echo_ham(self, ham: __main__.Ham) -> __main__.Ham
        """

        body = await request.body()
        print("len body: ", len(body))
        print("body: ", body)

        _jdict = {}
        if len(body) != 0:
            _jdict = json.loads(body)

        headers = request.headers
        logging.debug(f"headers: {headers}")
        self._check_lock(headers)

        _ham = _jdict["ham"]

        # code for obj: base_test.Ham
        _ham_obj = object.__new__(base_test.Ham)
        _a_attr = _ham["a"]
        setattr(_ham_obj, "a", _a_attr)

        _b_attr = _ham["b"]
        setattr(_ham_obj, "b", _b_attr)

        _ham = _ham_obj  # type: ignore
        # end obj: base_test.Ham

        _jdict["ham"] = _ham

        print("calling function: ", _jdict)
        _ret = self.echo_ham(**_jdict)
        print("called function: ", _ret)
        # code for object: <class '__main__.Ham'>
        _ret = _ret.__dict__  # type: ignore
        # end object: <class '__main__.Ham'>

        print("returning: ", _ret)
        return JSONResponse(_ret)

    async def _echo_hams_req(self, request):
        """Request for function:
        echo_hams(self, hams: List[__main__.Ham]) -> List[__main__.Ham]
        """

        body = await request.body()
        print("len body: ", len(body))
        print("body: ", body)

        _jdict = {}
        if len(body) != 0:
            _jdict = json.loads(body)

        headers = request.headers
        logging.debug(f"headers: {headers}")
        self._check_lock(headers)

        _hams = _jdict["hams"]
        # code for list: typing.List[base_test.Ham]
        if not json_is_type_match(typing.List[base_test.Ham], _hams):
            raise ValueError(
                "JSON from 'hams' returned does not match type: typing.List[__main__.Ham]"
            )

        _hams_list: typing.List[base_test.Ham] = []
        for _a_val in _hams:
            # code for obj: base_test.Ham
            _a_val_obj = object.__new__(base_test.Ham)
            _a_attr = _a_val["a"]
            setattr(_a_val_obj, "a", _a_attr)

            _b_attr = _a_val["b"]
            setattr(_a_val_obj, "b", _b_attr)

            _a_val = _a_val_obj  # type: ignore
            # end obj: base_test.Ham

            _hams_list.append(_a_val)  # type: ignore
        _hams = _hams_list
        # end list: typing.List[base_test.Ham]

        _jdict["hams"] = _hams

        print("calling function: ", _jdict)
        _ret = self.echo_hams(**_jdict)
        print("called function: ", _ret)
        # code for list: typing.List[__main__.Ham]
        _ret_list = []
        for _b_val in _ret:  # type: ignore
            # code for object: <class '__main__.Ham'>
            _b_val = _b_val.__dict__  # type: ignore
            # end object: <class '__main__.Ham'>

            _ret_list.append(_b_val)
        _ret = _ret_list
        # end list: typing.List[__main__.Ham]

        _ret = {"value": _ret}

        print("returning: ", _ret)
        return JSONResponse(_ret)

    async def _ham_tuple_req(self, request):
        """Request for function:
        ham_tuple(self, hammy: Tuple[str, __main__.Ham]) -> Tuple[str, __main__.Ham]  # noqa
        """

        body = await request.body()
        print("len body: ", len(body))
        print("body: ", body)

        _jdict = {}
        if len(body) != 0:
            _jdict = json.loads(body)

        headers = request.headers
        logging.debug(f"headers: {headers}")
        self._check_lock(headers)

        _hammy = _jdict["hammy"]
        # code for tuple: typing.Tuple[str, base_test.Ham]
        _hammy_tuple: typing.Tuple[str, base_test.Ham] = ()  # type: ignore

        # code for tuple arg: <class 'str'>
        _hammy_0 = _hammy[0]
        _hammy_tuple = _hammy_tuple + (_hammy_0,)  # type: ignore
        # end tuple arg: <class 'str'>

        # code for tuple arg: <class '__main__.Ham'>
        _hammy_1 = _hammy[1]

        # code for obj: base_test.Ham
        _hammy_1_obj = object.__new__(base_test.Ham)
        _a_attr = _hammy_1["a"]
        setattr(_hammy_1_obj, "a", _a_attr)

        _b_attr = _hammy_1["b"]
        setattr(_hammy_1_obj, "b", _b_attr)

        _hammy_1 = _hammy_1_obj  # type: ignore
        # end obj: base_test.Ham

        _hammy_tuple = _hammy_tuple + (_hammy_1,)  # type: ignore
        # end tuple arg: <class '__main__.Ham'>

        _hammy = _hammy_tuple  # type: ignore
        # end tuple: typing.Tuple[str, base_test.Ham]

        _jdict["hammy"] = _hammy

        print("calling function: ", _jdict)
        _ret = self.ham_tuple(**_jdict)
        print("called function: ", _ret)
        # code for tuple: typing.Tuple[str, __main__.Ham]
        _ret_list = []
        # code for tuple arg: <class 'str'>
        _ret_0 = _ret[0]
        _ret_list.append(_ret_0)  # type: ignore
        # end tuple arg: <class 'str'>

        # code for tuple arg: <class '__main__.Ham'>
        _ret_1 = _ret[1]
        # code for object: <class '__main__.Ham'>
        _ret_1 = _ret_1.__dict__  # type: ignore
        # end object: <class '__main__.Ham'>

        _ret_list.append(_ret_1)  # type: ignore
        # end tuple arg: <class '__main__.Ham'>

        _ret = _ret_list  # type: ignore
        # end tuple: typing.Tuple[str, __main__.Ham]

        _ret = {"value": _ret}

        print("returning: ", _ret)
        return JSONResponse(_ret)

    async def _health_req(self, request):
        """Request for function:
        health(self) -> Dict[str, str]
        """

        body = await request.body()
        print("len body: ", len(body))
        print("body: ", body)

        _jdict = {}
        if len(body) != 0:
            _jdict = json.loads(body)

        headers = request.headers
        logging.debug(f"headers: {headers}")

        print("calling function: ", _jdict)
        _ret = self.health(**_jdict)
        print("called function: ", _ret)

        print("returning: ", _ret)
        return JSONResponse(_ret)

    async def _info_req(self, request):
        """Request for function:
        info(self) -> modelos.object.kind.ObjectInfo
        """

        body = await request.body()
        print("len body: ", len(body))
        print("body: ", body)

        _jdict = {}
        if len(body) != 0:
            _jdict = json.loads(body)

        headers = request.headers
        logging.debug(f"headers: {headers}")

        print("calling function: ", _jdict)
        _ret = self.info(**_jdict)
        print("called function: ", _ret)
        # code for object: <class 'modelos.object.kind.ObjectInfo'>
        _ret = _ret.__dict__  # type: ignore
        _ext: typing.Optional[typing.Dict[str, str]] = _ret["ext"]
        # code for union: typing.Optional[typing.Dict[str, str]]
        if deep_isinstance(_ext, None):
            pass
        elif deep_isinstance(_ext, typing.Dict[str, str]):
            pass
        else:
            raise ValueError(
                "Do not know how to serialize"
                + "parameter 'typing.Optional[typing.Dict[str, str]]' "
                + f"of type '{type(_ext)}'"
            )
        # end union: typing.Optional[typing.Dict[str, str]]

        _ret["ext"] = _ext
        # end object: <class 'modelos.object.kind.ObjectInfo'>

        print("returning: ", _ret)
        return JSONResponse(_ret)

    async def _lock_req(self, request):
        """Request for function:
        lock(self, key: Optional[str] = None, timeout: Optional[int] = None) -> None  # noqa
        """

        body = await request.body()
        print("len body: ", len(body))
        print("body: ", body)

        _jdict = {}
        if len(body) != 0:
            _jdict = json.loads(body)

        headers = request.headers
        logging.debug(f"headers: {headers}")

        if "key" in _jdict:
            _key = _jdict["key"]
            # code for union: typing.Optional[str]
            if _key is None:
                pass
            elif type(_key) == str:
                pass
            else:
                raise ValueError(
                    f"Argument could not be deserialized: key - type: {type(_key)}"
                )
            # end union: typing.Optional[str]

            _jdict["key"] = _key
        if "timeout" in _jdict:
            _timeout = _jdict["timeout"]
            # code for union: typing.Optional[int]
            if _timeout is None:
                pass
            elif type(_timeout) == int:
                pass
            else:
                raise ValueError(
                    f"Argument could not be deserialized: timeout - type: {type(_timeout)}"
                )
            # end union: typing.Optional[int]

            _jdict["timeout"] = _timeout

        print("calling function: ", _jdict)
        _ret = self.lock(**_jdict)
        print("called function: ", _ret)
        _ret = {"value": None}

        print("returning: ", _ret)
        return JSONResponse(_ret)

    async def _save_req(self, request):
        """Request for function:
        save(self, out_dir: str = './artifacts') -> None
        """

        body = await request.body()
        print("len body: ", len(body))
        print("body: ", body)

        _jdict = {}
        if len(body) != 0:
            _jdict = json.loads(body)

        headers = request.headers
        logging.debug(f"headers: {headers}")
        self._check_lock(headers)

        print("calling function: ", _jdict)
        _ret = self.save(**_jdict)
        print("called function: ", _ret)
        _ret = {"value": None}

        print("returning: ", _ret)
        return JSONResponse(_ret)

    async def _set_req(self, request):
        """Request for function:
        set(self, a: str, b: int) -> None
        """

        body = await request.body()
        print("len body: ", len(body))
        print("body: ", body)

        _jdict = {}
        if len(body) != 0:
            _jdict = json.loads(body)

        headers = request.headers
        logging.debug(f"headers: {headers}")
        self._check_lock(headers)

        print("calling function: ", _jdict)
        _ret = self.set(**_jdict)
        print("called function: ", _ret)
        _ret = {"value": None}

        print("returning: ", _ret)
        return JSONResponse(_ret)

    async def _stream_req(self, websocket):
        """Request for function:
        stream(self, a: str, num: int) -> Iterator[str]
        """

        await websocket.accept()
        headers = websocket.headers
        logging.debug(f"headers: {headers}")
        self._check_lock(headers)

        # Process incoming messages
        qs = parse.parse_qs(str(websocket.query_params))

        _jdict = {}
        if "data" in qs and len(qs["data"]) > 0:
            _jdict = json.loads(qs["data"][0])

        print("jdict: ", _jdict)
        for _ret in self.stream(**_jdict):
            _ret = {"value": _ret}

            print("sending json")
            await websocket.send_json(_ret)
            print("sent")

        print("all done sending data, closing socket")
        await websocket.close()

    async def _unlock_req(self, request):
        """Request for function:
        unlock(self, key: Optional[str] = None, force: bool = False) -> None
        """

        body = await request.body()
        print("len body: ", len(body))
        print("body: ", body)

        _jdict = {}
        if len(body) != 0:
            _jdict = json.loads(body)

        headers = request.headers
        logging.debug(f"headers: {headers}")

        if "key" in _jdict:
            _key = _jdict["key"]
            # code for union: typing.Optional[str]
            if _key is None:
                pass
            elif type(_key) == str:
                pass
            else:
                raise ValueError(
                    f"Argument could not be deserialized: key - type: {type(_key)}"
                )
            # end union: typing.Optional[str]

            _jdict["key"] = _key

        print("calling function: ", _jdict)
        _ret = self.unlock(**_jdict)
        print("called function: ", _ret)
        _ret = {"value": None}

        print("returning: ", _ret)
        return JSONResponse(_ret)

    async def _labels_req(self, request):
        """Request for function:
        labels() -> Dict[str, str]
        """

        body = await request.body()
        print("len body: ", len(body))
        print("body: ", body)

        _jdict = {}
        if len(body) != 0:
            _jdict = json.loads(body)

        headers = request.headers
        logging.debug(f"headers: {headers}")
        self._check_lock(headers)

        print("calling function: ", _jdict)
        _ret = self.labels(**_jdict)
        print("called function: ", _ret)

        print("returning: ", _ret)
        return JSONResponse(_ret)

    async def _name_req(self, request):
        """Request for function:
        name() -> str
        """

        body = await request.body()
        print("len body: ", len(body))
        print("body: ", body)

        _jdict = {}
        if len(body) != 0:
            _jdict = json.loads(body)

        headers = request.headers
        logging.debug(f"headers: {headers}")
        self._check_lock(headers)

        print("calling function: ", _jdict)
        _ret = self.name(**_jdict)
        print("called function: ", _ret)
        _ret = {"value": _ret}

        print("returning: ", _ret)
        return JSONResponse(_ret)

    async def _short_name_req(self, request):
        """Request for function:
        short_name() -> str
        """

        body = await request.body()
        print("len body: ", len(body))
        print("body: ", body)

        _jdict = {}
        if len(body) != 0:
            _jdict = json.loads(body)

        headers = request.headers
        logging.debug(f"headers: {headers}")
        self._check_lock(headers)

        print("calling function: ", _jdict)
        _ret = self.short_name(**_jdict)
        print("called function: ", _ret)
        _ret = {"value": _ret}

        print("returning: ", _ret)
        return JSONResponse(_ret)

    def _routes(self) -> List[BaseRoute]:
        return [
            Route("/add", endpoint=self._add_req, methods=["POST"]),
            Route("/bake_hams", endpoint=self._bake_hams_req, methods=["POST"]),
            Route("/cook_eggs", endpoint=self._cook_eggs_req, methods=["POST"]),
            Route("/echo", endpoint=self._echo_req, methods=["POST"]),
            Route("/echo_ham", endpoint=self._echo_ham_req, methods=["POST"]),
            Route("/echo_hams", endpoint=self._echo_hams_req, methods=["POST"]),
            Route("/ham_tuple", endpoint=self._ham_tuple_req, methods=["POST"]),
            Route("/health", endpoint=self._health_req, methods=["GET", "POST"]),
            Route("/info", endpoint=self._info_req, methods=["POST"]),
            Route("/lock", endpoint=self._lock_req, methods=["POST"]),
            Route("/save", endpoint=self._save_req, methods=["POST"]),
            Route("/set", endpoint=self._set_req, methods=["POST"]),
            WebSocketRoute("/stream", endpoint=self._stream_req),
            Route("/unlock", endpoint=self._unlock_req, methods=["POST"]),
            Route("/labels", endpoint=self._labels_req, methods=["POST"]),
            Route("/name", endpoint=self._name_req, methods=["POST"]),
            Route("/short_name", endpoint=self._short_name_req, methods=["POST"]),
        ]


o = BarServer.from_env()
pkgs = o._reload_dirs()

app = Starlette(routes=o._routes())

if __name__ == "__main__":
    logging.info(f"starting server version '{o.scm.sha()}' on port: 8080")
    uvicorn.run(
        "__main__:app",
        host="0.0.0.0",
        port=8080,
        log_level="info",
        workers=1,
        reload=True,
        reload_dirs=pkgs.keys(),
    )
