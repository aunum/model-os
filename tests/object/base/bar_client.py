# This file was generated by ModelOS
import json
import os
import socket
import typing
from pathlib import Path
from typing import Type
from urllib import parse, request

import base_test
from lib_programname import get_path_executed_script
from websocket import create_connection

import modelos.object.kind
from modelos import Client
from modelos.object.encoding import deep_isinstance, json_is_type_match
from modelos.object.opts import Opts, OptsBuilder

if get_path_executed_script() == Path(os.path.dirname(__file__)).joinpath(
    Path("base_test.py")
):
    import __main__ as resource_test  # type: ignore # noqa


class BarClient(Client):
    """A resource client for Bar"""

    uri: str = "aunum/mdl-test:bar-05053de-4836945"

    def __init__(self, a: str, b: int, **kwargs) -> None:
        """A Bar resource

        Args:
            a (str): A string
            b (int): An int
        """
        ClientOpts = OptsBuilder[Opts].build(self.__class__)
        opts = ClientOpts(a=a, b=b)
        super().__init__(opts=opts, **kwargs)

    def add(self, x: int, y: int) -> int:
        """Add x to y

        Args:
            x (int): Number
            y (int): Number

        Returns:
            int: Sum
        """

        _params = json.dumps({"x": x, "y": y}).encode("utf8")
        _headers = {"content-type": "application/json", "client-uuid": str(self.uid)}
        _req = request.Request(
            f"{self.server_addr}/add",
            data=_params,
            headers=_headers,
        )
        _resp = request.urlopen(_req)
        _data = _resp.read().decode("utf-8")
        _jdict = json.loads(_data)

        if _jdict is None:
            raise ValueError("recieved invalid response from server, check server logs")

        if "value" in _jdict:
            _jdict = _jdict["value"]

        _ret: int
        _ret = _jdict

        return _ret

    def bake_hams(
        self, ham_by_name: typing.Dict[str, base_test.Ham]
    ) -> typing.Dict[str, base_test.Ham]:
        """Bake the given hams

        Args:
            ham_by_name (Dict[str, Ham]): A map of Ham to name

        Returns:
            Dict[str, bool]: Whether the Hams were baked
        """
        # code for dict arg: typing.Dict[str, __main__.Ham]
        _ham_by_name_dict = {}
        for _a_key, _b_val in ham_by_name.items():
            # code for object: <class '__main__.Ham'>
            _b_val = _b_val.__dict__  # type: ignore
            # end object: <class '__main__.Ham'>

            _ham_by_name_dict[_a_key] = _b_val
        ham_by_name = _ham_by_name_dict  # type: ignore
        # end dict: typing.Dict[str, __main__.Ham]

        _params = json.dumps({"ham_by_name": ham_by_name}).encode("utf8")
        _headers = {"content-type": "application/json", "client-uuid": str(self.uid)}
        _req = request.Request(
            f"{self.server_addr}/bake_hams",
            data=_params,
            headers=_headers,
        )
        _resp = request.urlopen(_req)
        _data = _resp.read().decode("utf-8")
        _jdict = json.loads(_data)

        if _jdict is None:
            raise ValueError("recieved invalid response from server, check server logs")

        if "value" in _jdict:
            _jdict = _jdict["value"]

        _ret: typing.Dict[str, base_test.Ham]
        # code for arg: typing.Dict[str, __main__.Ham]
        if not json_is_type_match(typing.Dict[str, base_test.Ham], _jdict):
            raise ValueError(
                "JSON returned does not match type: typing.Dict[str, base_test.Ham]"
            )
        _c_dict: typing.Dict[str, base_test.Ham] = {}
        for _d_key, _e_val in _jdict.items():
            # code for object: <class '__main__.Ham'>
            if not json_is_type_match(base_test.Ham, _e_val):
                raise ValueError("JSON returned does not match type: base_test.Ham")
            _c_obj = object.__new__(base_test.Ham)  # type: ignore
            _a = _e_val["a"]
            setattr(_c_obj, "a", _a)

            _b = _e_val["b"]
            setattr(_c_obj, "b", _b)

            _c = _c_obj
            # end object: <class '__main__.Ham'>

            _c_dict[_d_key] = _c  # type: ignore
        _ret = _c_dict
        # end dict: typing.Dict[str, __main__.Ham]

        return _ret

    def cook_eggs(
        self, egg_by_name: typing.Dict[str, base_test.Eggs]
    ) -> typing.Dict[str, base_test.Eggs]:
        """Bake the eggs

        Args:
            egg_by_name (Dict[str, Ham]): A map of egg to name

        Returns:
            Dict[str, bool]: Whether the eggs were cooked
        """
        # code for dict arg: typing.Dict[str, __main__.Eggs]
        _egg_by_name_dict = {}
        for _a_key, _b_val in egg_by_name.items():
            # code for object: <class '__main__.Eggs'>
            _b_val = _b_val.__dict__  # type: ignore
            h: base_test.Ham = _b_val["h"]  # type: ignore
            # code for object: <class '__main__.Ham'>
            h = h.__dict__  # type: ignore
            # end object: <class '__main__.Ham'>

            _b_val["h"] = h  # type: ignore
            b: typing.Dict[str, base_test.Ham] = _b_val["b"]  # type: ignore
            # code for dict arg: typing.Dict[str, __main__.Ham]
            _b_dict = {}
            for _c_key, _d_val in b.items():
                # code for object: <class '__main__.Ham'>
                _d_val = _d_val.__dict__  # type: ignore
                # end object: <class '__main__.Ham'>

                _b_dict[_c_key] = _d_val
            b = _b_dict  # type: ignore
            # end dict: typing.Dict[str, __main__.Ham]

            _b_val["b"] = b  # type: ignore
            # end object: <class '__main__.Eggs'>

            _egg_by_name_dict[_a_key] = _b_val
        egg_by_name = _egg_by_name_dict  # type: ignore
        # end dict: typing.Dict[str, __main__.Eggs]

        _params = json.dumps({"egg_by_name": egg_by_name}).encode("utf8")
        _headers = {"content-type": "application/json", "client-uuid": str(self.uid)}
        _req = request.Request(
            f"{self.server_addr}/cook_eggs",
            data=_params,
            headers=_headers,
        )
        _resp = request.urlopen(_req)
        _data = _resp.read().decode("utf-8")
        _jdict = json.loads(_data)

        if _jdict is None:
            raise ValueError("recieved invalid response from server, check server logs")

        if "value" in _jdict:
            _jdict = _jdict["value"]

        _ret: typing.Dict[str, base_test.Eggs]
        # code for arg: typing.Dict[str, __main__.Eggs]
        if not json_is_type_match(typing.Dict[str, base_test.Eggs], _jdict):
            raise ValueError(
                "JSON returned does not match type: typing.Dict[str, base_test.Eggs]"
            )
        _e_dict: typing.Dict[str, base_test.Eggs] = {}
        for _f_key, _g_val in _jdict.items():
            # code for object: <class '__main__.Eggs'>
            if not json_is_type_match(base_test.Eggs, _g_val):
                raise ValueError("JSON returned does not match type: base_test.Eggs")
            _e_obj = object.__new__(base_test.Eggs)  # type: ignore
            _h = _g_val["h"]
            # code for object: <class '__main__.Ham'>
            if not json_is_type_match(base_test.Ham, _h):
                raise ValueError("JSON returned does not match type: base_test.Ham")
            _h_obj = object.__new__(base_test.Ham)  # type: ignore
            _a = _h["a"]
            setattr(_h_obj, "a", _a)

            _b = _h["b"]
            setattr(_h_obj, "b", _b)

            _h = _h_obj
            # end object: <class '__main__.Ham'>

            setattr(_e_obj, "h", _h)

            _b = _g_val["b"]
            # code for arg: typing.Dict[str, __main__.Ham]
            if not json_is_type_match(typing.Dict[str, base_test.Ham], _b):
                raise ValueError(
                    "JSON returned does not match type: typing.Dict[str, base_test.Ham]"
                )
            _h_dict: typing.Dict[str, base_test.Ham] = {}
            for _i_key, _j_val in _b.items():
                # code for object: <class '__main__.Ham'>
                if not json_is_type_match(base_test.Ham, _j_val):
                    raise ValueError("JSON returned does not match type: base_test.Ham")
                _h_obj = object.__new__(base_test.Ham)  # type: ignore
                _a = _j_val["a"]
                setattr(_h_obj, "a", _a)

                _b = _j_val["b"]
                setattr(_h_obj, "b", _b)

                _h = _h_obj
                # end object: <class '__main__.Ham'>

                _h_dict[_i_key] = _h  # type: ignore
            _b = _h_dict
            # end dict: typing.Dict[str, __main__.Ham]

            setattr(_e_obj, "b", _b)

            _e = _e_obj
            # end object: <class '__main__.Eggs'>

            _e_dict[_f_key] = _e  # type: ignore
        _ret = _e_dict
        # end dict: typing.Dict[str, __main__.Eggs]

        return _ret

    def echo(self, txt: str) -> str:
        """Echo a string back

        Args:
            txt (str): String to echo

        Returns:
            str: String echoed with a hello
        """

        _params = json.dumps({"txt": txt}).encode("utf8")
        _headers = {"content-type": "application/json", "client-uuid": str(self.uid)}
        _req = request.Request(
            f"{self.server_addr}/echo",
            data=_params,
            headers=_headers,
        )
        _resp = request.urlopen(_req)
        _data = _resp.read().decode("utf-8")
        _jdict = json.loads(_data)

        if _jdict is None:
            raise ValueError("recieved invalid response from server, check server logs")

        if "value" in _jdict:
            _jdict = _jdict["value"]

        _ret: str
        _ret = _jdict

        return _ret

    def echo_ham(self, ham: base_test.Ham) -> base_test.Ham:
        """Echo a Ham

        Args:
            ham (Ham): Ham to echo

        Returns:
            Ham: Ham echoed
        """
        # code for object: <class '__main__.Ham'>
        ham = ham.__dict__  # type: ignore
        # end object: <class '__main__.Ham'>

        _params = json.dumps({"ham": ham}).encode("utf8")
        _headers = {"content-type": "application/json", "client-uuid": str(self.uid)}
        _req = request.Request(
            f"{self.server_addr}/echo_ham",
            data=_params,
            headers=_headers,
        )
        _resp = request.urlopen(_req)
        _data = _resp.read().decode("utf-8")
        _jdict = json.loads(_data)

        if _jdict is None:
            raise ValueError("recieved invalid response from server, check server logs")

        if "value" in _jdict:
            _jdict = _jdict["value"]

        _ret: base_test.Ham
        # code for object: <class '__main__.Ham'>
        if not json_is_type_match(base_test.Ham, _jdict):
            raise ValueError("JSON returned does not match type: base_test.Ham")
        _ret_obj = object.__new__(base_test.Ham)  # type: ignore
        _a = _jdict["a"]
        setattr(_ret_obj, "a", _a)

        _b = _jdict["b"]
        setattr(_ret_obj, "b", _b)

        _ret = _ret_obj
        # end object: <class '__main__.Ham'>

        return _ret

    def echo_hams(self, hams: typing.List[base_test.Ham]) -> typing.List[base_test.Ham]:
        """Echo Hams

        Args:
            hams (List[Ham]): A list of Hams

        Returns:
            List[Ham]: A list of Hams
        """
        # code for list arg: typing.List[__main__.Ham]
        _hams_list = []
        for _a_val in hams:
            # code for object: <class '__main__.Ham'>
            _a_val = _a_val.__dict__  # type: ignore
            # end object: <class '__main__.Ham'>

            _hams_list.append(_a_val)
        hams = _hams_list
        # end list: typing.List[__main__.Ham]

        _params = json.dumps({"hams": hams}).encode("utf8")
        _headers = {"content-type": "application/json", "client-uuid": str(self.uid)}
        _req = request.Request(
            f"{self.server_addr}/echo_hams",
            data=_params,
            headers=_headers,
        )
        _resp = request.urlopen(_req)
        _data = _resp.read().decode("utf-8")
        _jdict = json.loads(_data)

        if _jdict is None:
            raise ValueError("recieved invalid response from server, check server logs")

        if "value" in _jdict:
            _jdict = _jdict["value"]

        _ret: typing.List[base_test.Ham]
        # code for arg: typing.List[__main__.Ham]
        _c_list: typing.List = []
        for _b_val in _jdict:
            # code for object: <class '__main__.Ham'>
            if not json_is_type_match(base_test.Ham, _b_val):
                raise ValueError("JSON returned does not match type: base_test.Ham")
            _c_obj = object.__new__(base_test.Ham)  # type: ignore
            _a = _b_val["a"]
            setattr(_c_obj, "a", _a)

            _b = _b_val["b"]
            setattr(_c_obj, "b", _b)

            _c = _c_obj
            # end object: <class '__main__.Ham'>

            _c_list.append(_c)
        _ret = _c_list
        # end list: typing.List[__main__.Ham]

        return _ret

    def ham_tuple(
        self, hammy: typing.Tuple[str, base_test.Ham]
    ) -> typing.Tuple[str, base_test.Ham]:
        """A Tuple of Hams

        Args:
            hammy (Tuple[str, Ham]): Name and Ham

        Returns:
            Tuple[str, Ham]: Name and Ham
        """
        # code for tuple: typing.Tuple[str, __main__.Ham]
        hammy_list: typing.List[typing.Any] = []
        # code for tuple arg: <class 'str'>
        hammy_0 = hammy[0]
        hammy_list.append(hammy_0)
        # end tuple arg: <class 'str'>

        # code for tuple arg: <class '__main__.Ham'>
        hammy_1 = hammy[1]
        # code for object: <class '__main__.Ham'>
        hammy_1 = hammy_1.__dict__  # type: ignore
        # end object: <class '__main__.Ham'>

        hammy_list.append(hammy_1)
        # end tuple arg: <class '__main__.Ham'>

        hammy = hammy_list  # type: ignore
        # end tuple: typing.Tuple[str, __main__.Ham]

        _params = json.dumps({"hammy": hammy}).encode("utf8")
        _headers = {"content-type": "application/json", "client-uuid": str(self.uid)}
        _req = request.Request(
            f"{self.server_addr}/ham_tuple",
            data=_params,
            headers=_headers,
        )
        _resp = request.urlopen(_req)
        _data = _resp.read().decode("utf-8")
        _jdict = json.loads(_data)

        if _jdict is None:
            raise ValueError("recieved invalid response from server, check server logs")

        if "value" in _jdict:
            _jdict = _jdict["value"]

        _ret: typing.Tuple[str, base_test.Ham]
        # code for tuple: typing.Tuple[str, __main__.Ham]
        _ret_tuple: typing.Tuple[str, base_test.Ham] = ()  # type: ignore

        # code for tuple arg: <class 'str'>
        _v_0 = _jdict[0]
        _a = _v_0
        _ret_tuple = _ret_tuple + (_a,)  # type: ignore
        # end tuple arg: <class 'str'>

        # code for tuple arg: <class '__main__.Ham'>
        _v_1 = _jdict[1]
        # code for object: <class '__main__.Ham'>
        if not json_is_type_match(base_test.Ham, _v_1):
            raise ValueError("JSON returned does not match type: base_test.Ham")
        _b_obj = object.__new__(base_test.Ham)  # type: ignore
        _a = _v_1["a"]
        setattr(_b_obj, "a", _a)

        _b = _v_1["b"]
        setattr(_b_obj, "b", _b)

        _b = _b_obj
        # end object: <class '__main__.Ham'>

        _ret_tuple = _ret_tuple + (_b,)  # type: ignore
        # end tuple arg: <class '__main__.Ham'>

        _ret = _ret_tuple  # type: ignore
        # end tuple: typing.Tuple[str, __main__.Ham]

        return _ret

    def health(self) -> typing.Dict[str, str]:
        """Health of the resource

        Returns:
            Dict[str, Any]: Resource health
        """

        _params = json.dumps({}).encode("utf8")
        _headers = {"content-type": "application/json", "client-uuid": str(self.uid)}
        _req = request.Request(
            f"{self.server_addr}/health",
            data=_params,
            headers=_headers,
        )
        _resp = request.urlopen(_req)
        _data = _resp.read().decode("utf-8")
        _jdict = json.loads(_data)

        if _jdict is None:
            raise ValueError("recieved invalid response from server, check server logs")

        if "value" in _jdict:
            _jdict = _jdict["value"]

        _ret: typing.Dict[str, str]
        # code for arg: typing.Dict[str, str]
        if not json_is_type_match(typing.Dict[str, str], _jdict):
            raise ValueError("JSON returned does not match type: typing.Dict[str, str]")
        _ret = _jdict
        # end dict: typing.Dict[str, str]

        return _ret

    def info(self) -> modelos.object.kind.ObjectInfo:
        """Info about the resource

        Returns:
            Dict[str, Any]: Resource info
        """

        _params = json.dumps({}).encode("utf8")
        _headers = {"content-type": "application/json", "client-uuid": str(self.uid)}
        _req = request.Request(
            f"{self.server_addr}/info",
            data=_params,
            headers=_headers,
        )
        _resp = request.urlopen(_req)
        _data = _resp.read().decode("utf-8")
        _jdict = json.loads(_data)

        if _jdict is None:
            raise ValueError("recieved invalid response from server, check server logs")

        if "value" in _jdict:
            _jdict = _jdict["value"]

        _ret: modelos.object.kind.ObjectInfo
        # code for object: <class 'modelos.object.kind.ObjectInfo'>
        if not json_is_type_match(modelos.object.kind.ObjectInfo, _jdict):
            raise ValueError(
                "JSON returned does not match type: modelos.object.kind.ObjectInfo"
            )
        _ret_obj = object.__new__(modelos.object.kind.ObjectInfo)  # type: ignore
        _name = _jdict["name"]
        setattr(_ret_obj, "name", _name)

        _version = _jdict["version"]
        setattr(_ret_obj, "version", _version)

        _env_sha = _jdict["env_sha"]
        setattr(_ret_obj, "env_sha", _env_sha)

        _uri = _jdict["uri"]
        setattr(_ret_obj, "uri", _uri)

        _server_entrypoint = _jdict["server_entrypoint"]
        setattr(_ret_obj, "server_entrypoint", _server_entrypoint)

        _locked = _jdict["locked"]
        setattr(_ret_obj, "locked", _locked)

        _ext = _jdict["ext"]
        # code for union: typing.Optional[typing.Dict[str, str]]
        if json_is_type_match(typing.Dict[str, str], _ext):
            # code for arg: typing.Dict[str, str]
            _ret = _ext
            # end dict: typing.Dict[str, str]

        elif json_is_type_match(None, _ext):
            _ret = _ext
        else:
            raise ValueError(f"Unable to deserialize return value: {type(_ext)}")
        # end union: typing.Optional[typing.Dict[str, str]]

        setattr(_ret_obj, "ext", _ext)

        _ret = _ret_obj
        # end object: <class 'modelos.object.kind.ObjectInfo'>

        return _ret

    def lock(
        self, key: typing.Optional[str] = None, timeout: typing.Optional[int] = None
    ) -> None:
        """Lock the process to only operate with the caller

        Args:
            key (Optional[str], optional): An optional key to secure the lock
            timeout (Optional[int], optional): Whether to unlock after a set amount of time. Defaults to None.
        """
        # code for union: typing.Optional[str]
        if deep_isinstance(key, None):
            pass
        elif deep_isinstance(key, str):
            pass
        else:
            raise ValueError(
                "Do not know how to serialize "
                + "parameter 'key' "
                + f"of type '{type(key)}'"
            )
        # end union: typing.Optional[str]

        # code for union: typing.Optional[int]
        if deep_isinstance(timeout, None):
            pass
        elif deep_isinstance(timeout, int):
            pass
        else:
            raise ValueError(
                "Do not know how to serialize "
                + "parameter 'timeout' "
                + f"of type '{type(timeout)}'"
            )
        # end union: typing.Optional[int]

        _params = json.dumps({"key": key, "timeout": timeout}).encode("utf8")
        _headers = {"content-type": "application/json", "client-uuid": str(self.uid)}
        _req = request.Request(
            f"{self.server_addr}/lock",
            data=_params,
            headers=_headers,
        )
        _resp = request.urlopen(_req)
        _data = _resp.read().decode("utf-8")
        _jdict = json.loads(_data)

        if _jdict is None:
            raise ValueError("recieved invalid response from server, check server logs")

        if "value" in _jdict:
            _jdict = _jdict["value"]

        _ret: None
        _ret = _jdict

        return _ret

    def save(self, out_dir: str = "./artifacts") -> None:
        """Save the object

        Args:
            out_dir (str, optional): Directory to output the artiacts. Defaults to "./artifacts".
        """

        _params = json.dumps({"out_dir": out_dir}).encode("utf8")
        _headers = {"content-type": "application/json", "client-uuid": str(self.uid)}
        _req = request.Request(
            f"{self.server_addr}/save",
            data=_params,
            headers=_headers,
        )
        _resp = request.urlopen(_req)
        _data = _resp.read().decode("utf-8")
        _jdict = json.loads(_data)

        if _jdict is None:
            raise ValueError("recieved invalid response from server, check server logs")

        if "value" in _jdict:
            _jdict = _jdict["value"]

        _ret: None
        _ret = _jdict

        return _ret

    def set(self, a: str, b: int) -> None:
        """Set the params

        Args:
            a (str): A string
            b (int): An int
        """

        _params = json.dumps({"a": a, "b": b}).encode("utf8")
        _headers = {"content-type": "application/json", "client-uuid": str(self.uid)}
        _req = request.Request(
            f"{self.server_addr}/set",
            data=_params,
            headers=_headers,
        )
        _resp = request.urlopen(_req)
        _data = _resp.read().decode("utf-8")
        _jdict = json.loads(_data)

        if _jdict is None:
            raise ValueError("recieved invalid response from server, check server logs")

        if "value" in _jdict:
            _jdict = _jdict["value"]

        _ret: None
        _ret = _jdict

        return _ret

    def stream(self, a: str, num: int) -> typing.Iterator[str]:
        """Stream back the string for the given number of times

        Args:
            a (str): String to stream
            num (int): Number of times to return

        Yields:
            Iterator[str]: An iterator
        """
        _server_addr = (
            f"{self.pod_name}.pod.{self.pod_namespace}.kubernetes:{self.server_port}"
        )

        _sock = socket.create_connection(
            (f"{self.pod_name}.pod.{self.pod_namespace}.kubernetes", self.server_port)
        )

        _encoded = parse.urlencode({"data": json.dumps({"a": a, "num": num})})
        _ws = create_connection(
            f"ws://{_server_addr}/stream?{_encoded}",
            header=[f"client-uuid: {str(self.uid)}"],
            socket=_sock,
        )
        try:
            while True:
                code, _data = _ws.recv_data()
                if code == 8:
                    break
                _jdict = json.loads(_data)
                if "value" in _jdict:
                    _jdict = _jdict["value"]
                _ret: str
                _ret = _jdict

                yield _ret

        except Exception as e:
            print("stream exception: ", e)
            raise e

    def unlock(self, key: typing.Optional[str] = None, force: bool = False) -> None:
        """Unlock the kind

        Args:
            key (Optional[str], optional): Key to unlock, if needed. Defaults to None.
            force (bool, optional): Force unlock without a key. Defaults to False.
        """
        # code for union: typing.Optional[str]
        if deep_isinstance(key, None):
            pass
        elif deep_isinstance(key, str):
            pass
        else:
            raise ValueError(
                "Do not know how to serialize "
                + "parameter 'key' "
                + f"of type '{type(key)}'"
            )
        # end union: typing.Optional[str]

        _params = json.dumps({"key": key, "force": force}).encode("utf8")
        _headers = {"content-type": "application/json", "client-uuid": str(self.uid)}
        _req = request.Request(
            f"{self.server_addr}/unlock",
            data=_params,
            headers=_headers,
        )
        _resp = request.urlopen(_req)
        _data = _resp.read().decode("utf-8")
        _jdict = json.loads(_data)

        if _jdict is None:
            raise ValueError("recieved invalid response from server, check server logs")

        if "value" in _jdict:
            _jdict = _jdict["value"]

        _ret: None
        _ret = _jdict

        return _ret

    def labels(self) -> typing.Dict[str, str]:  # type: ignore
        """Labels for the resource

        Args:
            scm (Optional[SCM], optional): SCM to use. Defaults to None.

        Returns:
            Dict[str, Any]: Labels for the server
        """

        _params = json.dumps({}).encode("utf8")
        _headers = {"content-type": "application/json", "client-uuid": str(self.uid)}
        _req = request.Request(
            f"{self.server_addr}/labels",
            data=_params,
            headers=_headers,
        )
        _resp = request.urlopen(_req)
        _data = _resp.read().decode("utf-8")
        _jdict = json.loads(_data)

        if _jdict is None:
            raise ValueError("recieved invalid response from server, check server logs")

        if "value" in _jdict:
            _jdict = _jdict["value"]

        _ret: typing.Dict[str, str]
        # code for arg: typing.Dict[str, str]
        if not json_is_type_match(typing.Dict[str, str], _jdict):
            raise ValueError("JSON returned does not match type: typing.Dict[str, str]")
        _ret = _jdict
        # end dict: typing.Dict[str, str]

        return _ret

    def name(self) -> str:  # type: ignore
        """Name of the resource

        Returns:
            str: Name of the server
        """

        _params = json.dumps({}).encode("utf8")
        _headers = {"content-type": "application/json", "client-uuid": str(self.uid)}
        _req = request.Request(
            f"{self.server_addr}/name",
            data=_params,
            headers=_headers,
        )
        _resp = request.urlopen(_req)
        _data = _resp.read().decode("utf-8")
        _jdict = json.loads(_data)

        if _jdict is None:
            raise ValueError("recieved invalid response from server, check server logs")

        if "value" in _jdict:
            _jdict = _jdict["value"]

        _ret: str
        _ret = _jdict

        return _ret

    def short_name(self) -> str:  # type: ignore
        """Short name for the resource

        Returns:
            str: A short name
        """

        _params = json.dumps({}).encode("utf8")
        _headers = {"content-type": "application/json", "client-uuid": str(self.uid)}
        _req = request.Request(
            f"{self.server_addr}/short_name",
            data=_params,
            headers=_headers,
        )
        _resp = request.urlopen(_req)
        _data = _resp.read().decode("utf-8")
        _jdict = json.loads(_data)

        if _jdict is None:
            raise ValueError("recieved invalid response from server, check server logs")

        if "value" in _jdict:
            _jdict = _jdict["value"]

        _ret: str
        _ret = _jdict

        return _ret

    def _super_init(self, uri: str) -> None:
        super().__init__(uri)

    @classmethod
    def from_uri(cls: Type["BarClient"], uri: str) -> "BarClient":
        c = cls.__new__(cls)
        c._super_init(uri)
        return c
